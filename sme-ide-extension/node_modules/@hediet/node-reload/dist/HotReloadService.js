"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModuleChangeInfo = exports.TrackedModule = exports.HotReloadService = void 0;
const FileWatcher_1 = require("./FileWatcher");
const logging_1 = require("./logging");
const nodeApi_1 = require("./nodeApi");
const utils_1 = require("./utils");
class HotReloadService {
    static { this._instance = undefined; }
    static get instance() { return this._instance; }
    static initialize(options) {
        if (this._instance) {
            if (!options.skipInitializationIfEnabled) {
                console.error('HotReloadService already initialized, ignoring subsequent initialization call. (Set skipInitializationIfEnabled option to true to suppress this warning.)');
            }
        }
        else {
            this._instance = new HotReloadService(new logging_1.Logger((0, logging_1.getLogLevel)(options.logging), options.loggingFileRoot), predicateFromStringArray(options.ignoredModules ?? ['.*[/\\\\]node_modules[/\\\\].*']), predicateFromStringArray(options.ignoredModules ?? ['vscode']));
            this._instance.trackModule(options.entryModule);
        }
    }
    constructor(_logger, _shouldIgnoreModule, _shouldIgnoreRequireRequest) {
        this._logger = _logger;
        this._shouldIgnoreModule = _shouldIgnoreModule;
        this._shouldIgnoreRequireRequest = _shouldIgnoreRequireRequest;
        this.interceptor = (0, nodeApi_1.registerModuleInterceptors)({
            interceptLoad: (module, filename) => {
                const loadResult = this.interceptor.originalLoad(module, filename);
                this._onAfterLoad(filename);
                return loadResult;
            },
            interceptRequire: (module, filename) => {
                const { didLog } = this._onBeforeRequire(module, filename);
                if (didLog) {
                    this._logger.indent();
                }
                try {
                    const result = this.interceptor.originalRequire(module, filename);
                    return result;
                }
                finally {
                    if (didLog) {
                        this._logger.unindent();
                    }
                }
            },
        });
        this._trackedModules = new Map();
        this._watcher = new FileWatcher_1.FileWatcher(filenames => this._handleFileChanges(filenames));
        this._onTrackedModuleExportsLoaded = new utils_1.EventEmitter();
        this.onTrackedModuleExportsLoaded = this._onTrackedModuleExportsLoaded.event;
        this._logger.logHotReloadActive();
    }
    trackModule(module) {
        this._getOrCreateTrackedModule(module.filename);
        setTimeout(() => {
            this._onAfterLoad(module.filename);
        }, 0);
    }
    _getOrCreateTrackedModule(filename) {
        const existing = this._trackedModules.get(filename);
        if (existing) {
            return existing;
        }
        const trackedModule = new TrackedModule(filename, this, this._logger, () => this._watcher.addFile(filename));
        this._trackedModules.set(filename, trackedModule);
        return trackedModule;
    }
    _onBeforeRequire(module, request) {
        if (this._shouldIgnoreRequireRequest(request)) {
            const didLog = this._logger.logSkippingRequire(request, module.filename, 'ignored require request');
            return { didLog };
        }
        const requiredByModule = this._trackedModules.get(module.filename);
        if (!requiredByModule) {
            const didLog = this._logger.logSkippingRequire(request, module.filename, 'caller not tracked');
            return { didLog };
        }
        let requiredModuleFilename;
        try {
            requiredModuleFilename = (0, nodeApi_1.resolveFileName)(request, module);
        }
        catch (e) {
            const didLog = this._logger.logResolvingError(request, module.filename, e);
            return { didLog };
        }
        if (this._shouldIgnoreModule(requiredModuleFilename)) {
            const didLog = this._logger.logSkippingRequire(request, module.filename, 'required module ignored');
            return { didLog };
        }
        const didLog = this._logger.logTrackingRequire(request, module.filename, requiredModuleFilename);
        const requiredModule = this._getOrCreateTrackedModule(requiredModuleFilename);
        requiredModule.consumers.add(requiredByModule);
        return { didLog };
    }
    _onAfterLoad(filename) {
        const loadedModule = this._trackedModules.get(filename);
        if (loadedModule) {
            loadedModule.watch();
            loadedModule.exports = (0, nodeApi_1.getLoadedModule)(filename)?.exports;
            this._onTrackedModuleExportsLoaded.emit({ module: loadedModule });
        }
    }
    _handleFileChanges(filenames) {
        const didLog = this._logger.logFilesChanged(filenames);
        if (didLog) {
            this._logger.indent();
        }
        try {
            const modules = [];
            for (const filename of filenames) {
                const module = this._trackedModules.get(filename);
                if (module) {
                    modules.push(module);
                }
            }
            for (const module of modules) {
                module.beginUpdate([]);
                module.markChanged();
            }
            for (const module of modules) {
                module.endUpdate();
            }
        }
        finally {
            if (didLog) {
                this._logger.unindent();
            }
        }
    }
    markChanged(moduleOrFilename) {
        const moduleFilename = typeof moduleOrFilename === 'string'
            ? moduleOrFilename
            : moduleOrFilename.filename;
        this._handleFileChanges([moduleFilename]);
    }
}
exports.HotReloadService = HotReloadService;
function predicateFromStringArray(arr) {
    const regexes = arr.map(s => new RegExp(s));
    return str => {
        return regexes.some(r => r.test(str));
    };
}
class TrackedModule {
    registerUpdateStrategy(strategy) {
        this._updateStrategies.add(strategy);
        return {
            dispose: () => this._updateStrategies.delete(strategy),
        };
    }
    get active() { return this._active; }
    constructor(filename, _hotReloadService, _logger, _watch) {
        this.filename = filename;
        this._hotReloadService = _hotReloadService;
        this._logger = _logger;
        this._watch = _watch;
        this.consumers = new Set();
        this.exports = {};
        this._updateStrategies = new Set();
        this.updateStrategies = this._updateStrategies;
        this._updateCounter = 0;
        this._updatedCosumers = [];
        this._active = false;
        this._moduleChanged = false;
        this._changedDependencies = new Set();
        this._watcher = undefined;
    }
    watch() {
        if (this._watcher) {
            return;
        }
        this._watcher = this._watch();
    }
    beginUpdate(stack) {
        if (this._active) {
            throw new Error('Cannot begin update while update is in progress');
        }
        stack.push(this);
        this._active = true;
        this._updateCounter++;
        if (this._updateCounter === 1) {
            this._updatedCosumers = [];
            for (const c of this.consumers) {
                if (c.active) {
                    // recursion, ignore
                    stack.push(c);
                    this._logger.logRecursiveUpdate(stack.map(s => s.filename));
                    stack.pop();
                }
                else {
                    this._updatedCosumers.push(c);
                    c.beginUpdate(stack);
                }
            }
        }
        stack.pop();
        this._active = false;
    }
    endUpdate() {
        if (this._active) {
            throw new Error('Cannot begin update while update is in progress');
        }
        try {
            let didLog = false;
            let didLogUpdatingModule = false;
            this._active = true;
            this._updateCounter--;
            if (this._updateCounter === 0) {
                if (this._moduleChanged || this._changedDependencies.size > 0) {
                    const changeInfo = new ModuleChangeInfo(this, this._moduleChanged, new Set(this._changedDependencies));
                    this._moduleChanged = false;
                    this._changedDependencies.clear();
                    didLogUpdatingModule = this._logger.logUpdatingModule(this.filename);
                    if (didLogUpdatingModule) {
                        this._logger.indent();
                    }
                    let couldApplyUpdate = false;
                    for (const u of this.updateStrategies) {
                        const r = u.applyUpdate(changeInfo);
                        couldApplyUpdate = couldApplyUpdate || r;
                    }
                    if (couldApplyUpdate) {
                        didLog = this._logger.logModuleUpdated(this.filename);
                    }
                    else {
                        this.clearCache();
                        if (this._updatedCosumers.length === 0) {
                            didLog = this._logger.logEntryModuleUpdateFailed(this.filename);
                        }
                        else {
                            didLog = this._logger.logUpdateFailed(this.filename, this._updatedCosumers.length);
                            for (const consumer of this._updatedCosumers) {
                                consumer.markDependencyChanged(changeInfo);
                            }
                        }
                    }
                }
                if (didLog) {
                    this._logger.indent();
                }
                for (const consumer of this._updatedCosumers) {
                    consumer.endUpdate();
                }
                if (didLog) {
                    this._logger.unindent();
                }
                if (didLogUpdatingModule) {
                    this._logger.unindent();
                }
                this._updatedCosumers = [];
            }
            else {
                this._logger.logPostponeEndUpdate(this.filename, this._updateCounter);
            }
        }
        finally {
            this._active = false;
        }
    }
    markChanged() {
        this._checkUpdateInProgress();
        this._moduleChanged = true;
    }
    markDependencyChanged(changeInfo) {
        this._checkUpdateInProgress();
        this._changedDependencies.add(changeInfo);
    }
    _checkUpdateInProgress() {
        if (this._updateCounter === 0) {
            debugger;
            throw new Error('Cannot mark module as changed outside of an update');
        }
    }
    clearCache() {
        this._logger.logClearingModule(this.filename);
        (0, nodeApi_1.deleteModule)(this.filename);
    }
    reload() {
        this.clearCache();
        this._hotReloadService.interceptor.originalRequire((0, nodeApi_1.moduleFromNodeModule)(module), this.filename);
    }
    toString() {
        return `TrackedModule(${this.filename})`;
    }
}
exports.TrackedModule = TrackedModule;
class ModuleChangeInfo {
    constructor(module, 
    /**
     * Is set, if the current module changed.
     */
    moduleChanged, 
    /**
     * Describes the changes of the dependent modules.
     */
    dependencyChangeInfos) {
        this.module = module;
        this.moduleChanged = moduleChanged;
        this.dependencyChangeInfos = dependencyChangeInfos;
    }
    toString() {
        return JSON.stringify(this._toJson(), null, '\t');
    }
    _toJson() {
        return {
            moduleChanged: this.moduleChanged,
            dependencyChangeInfos: Object.fromEntries(this.dependencyChangeInfos.entries()),
        };
    }
}
exports.ModuleChangeInfo = ModuleChangeInfo;
//# sourceMappingURL=HotReloadService.js.map