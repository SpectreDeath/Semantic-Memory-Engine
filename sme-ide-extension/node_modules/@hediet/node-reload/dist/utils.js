"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Graph = exports.Node = exports.EventEmitter = exports.AsyncQueue = exports.Debouncer = void 0;
class Debouncer {
    run(delayMs, cb) {
        if (this._timeout) {
            clearTimeout(this._timeout);
        }
        this._timeout = setTimeout(cb, delayMs);
    }
    dispose() {
        if (this._timeout) {
            clearTimeout(this._timeout);
        }
    }
}
exports.Debouncer = Debouncer;
class AsyncQueue {
    constructor() {
        this._queue = [];
        this._running = false;
    }
    async _runNext() {
        if (this._running || this._queue.length === 0) {
            return;
        }
        this._running = true;
        const task = this._queue.shift();
        try {
            await task();
        }
        finally {
            this._running = false;
            this._runNext();
        }
    }
    schedule(task) {
        return new Promise((resolve, reject) => {
            this._queue.push(async () => {
                try {
                    resolve(await task());
                }
                catch (error) {
                    reject(error);
                }
            });
            this._runNext();
        });
    }
    clear() {
        this._queue.length = 0;
    }
}
exports.AsyncQueue = AsyncQueue;
class EventEmitter {
    constructor() {
        this._listeners = new Set();
        this.event = (listener) => {
            this._listeners.add(listener);
            return {
                dispose: () => {
                    this._listeners.delete(listener);
                }
            };
        };
    }
    emit(args) {
        for (const listener of this._listeners) {
            listener(args);
        }
    }
}
exports.EventEmitter = EventEmitter;
class Node {
    constructor(value, outNodes = [], inNodes = []) {
        this.value = value;
        this.outNodes = outNodes;
        this.inNodes = inNodes;
    }
}
exports.Node = Node;
class Graph {
    static build(roots, getOut) {
        const nodes = new Map();
        const getNode = (value) => {
            let node = nodes.get(value);
            if (!node) {
                node = new Node(value);
                nodes.set(value, node);
            }
            return node;
        };
        const build = (value) => {
            const node = getNode(value);
            for (const out of getOut(value)) {
                const outNode = build(out);
                node.outNodes.push(outNode);
                outNode.inNodes.push(node);
            }
            return node;
        };
        const rootNodes = roots.map(build);
        return new Graph(rootNodes);
    }
    constructor(roots) {
        this.roots = roots;
    }
}
exports.Graph = Graph;
//# sourceMappingURL=utils.js.map