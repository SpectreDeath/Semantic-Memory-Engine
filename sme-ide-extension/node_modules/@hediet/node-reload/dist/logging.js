"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = exports.LogLevel = void 0;
exports.getLogLevel = getLogLevel;
const path = require("path");
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Off"] = 0] = "Off";
    LogLevel[LogLevel["Warn"] = 1] = "Warn";
    LogLevel[LogLevel["Info"] = 2] = "Info";
    LogLevel[LogLevel["Trace"] = 3] = "Trace";
    LogLevel[LogLevel["Debug"] = 4] = "Debug";
})(LogLevel || (exports.LogLevel = LogLevel = {}));
function getLogLevel(options) {
    if (options === false) {
        return LogLevel.Off;
    }
    if (options === 'info' || options === true) {
        return LogLevel.Info;
    }
    if (options === 'trace') {
        return LogLevel.Trace;
    }
    if (options === 'debug') {
        return LogLevel.Debug;
    }
    return LogLevel.Info;
}
class Logger {
    static { this.TREE_BRANCH = '├── '; }
    static { this.TREE_VERTICAL = '│  '; }
    constructor(_logLevel, _root = process.cwd()) {
        this._logLevel = _logLevel;
        this._root = _root;
        this._indentation = 0;
    }
    _formatPath(filepath) {
        const result = path.relative(this._root, filepath);
        if (!path.isAbsolute(result)) {
            // so that ctrl+click works in vscode
            return `.${path.sep}${result}`;
        }
        return result;
    }
    logHotReloadActive() {
        return this._log(LogLevel.Info, `Hot reload active`);
    }
    logTrackingRequire(request, moduleFilename, resolvedFilename) {
        return this._log(LogLevel.Trace, `Tracking require from "${this._formatPath(moduleFilename)}" of "${request}" (resolved to "${this._formatPath(resolvedFilename)}")`);
    }
    logSkippingRequire(request, filename, reason) {
        return this._log(LogLevel.Debug, `Skipping require of "${request}" from "${this._formatPath(filename)}" (${reason})`);
    }
    logResolvingError(request, filename, error) {
        const detail = this._logLevel >= LogLevel.Debug ? ` (error: ${error})` : '';
        return this._log(LogLevel.Warn, `Error while resolving module "${request}" from "${this._formatPath(filename)}"${detail}`);
    }
    logFilesChanged(filenames) {
        return this._log(LogLevel.Info, `File(s) changed: ${filenames.map(f => this._formatPath(f)).join(', ')}`);
    }
    logUpdatingModule(filename) {
        return this._log(LogLevel.Trace, `Updating "${this._formatPath(filename)}"...`);
    }
    logClearingModule(filename) {
        return this._log(LogLevel.Trace, `Clearing "${this._formatPath(filename)}"`);
    }
    logModuleUpdated(filename) {
        return this._log(LogLevel.Info, `Successfully updated "${this._formatPath(filename)}"`);
    }
    logUpdateFailed(filename, consumerCount) {
        return this._log(LogLevel.Trace, `Could not update "${this._formatPath(filename)}", updating ${consumerCount} consumer(s)...`);
    }
    logEntryModuleUpdateFailed(filename) {
        return this._log(LogLevel.Warn, `Could not update entry module "${this._formatPath(filename)}"!`);
    }
    logRecursiveUpdate(stackFilenames) {
        const level = LogLevel.Info;
        if (!this._isLoggingEnabled(level)) {
            return false;
        }
        this._log(level, `Skipping recursive dependency update:`);
        this.indent();
        let first = true;
        for (const stackFilename of stackFilenames.reverse()) {
            this._log(level, `  ${first ? '' : `...requires `}"${this._formatPath(stackFilename)}"`);
            first = false;
        }
        this.unindent();
        return true;
    }
    logPostponeEndUpdate(filename, updateCounter) {
        return this._log(LogLevel.Trace, `Postponing endUpdate of "${this._formatPath(filename)}" (${updateCounter})`);
    }
    _isLoggingEnabled(level) {
        return this._logLevel >= level;
    }
    _getIndentation() {
        let result = '';
        for (let i = 0; i < this._indentation; i++) {
            result += i === this._indentation - 1 ? Logger.TREE_BRANCH : Logger.TREE_VERTICAL;
        }
        return result;
    }
    _log(level, message) {
        if (!this._isLoggingEnabled(level)) {
            return false;
        }
        const indentation = this._getIndentation();
        console.log(`[node-reload] ${indentation}${message}`);
        return true;
    }
    indent() {
        this._indentation++;
    }
    unindent() {
        this._indentation--;
    }
}
exports.Logger = Logger;
//# sourceMappingURL=logging.js.map